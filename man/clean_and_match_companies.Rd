% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clean_and_match_companies.R
\name{clean_and_match_companies}
\alias{clean_and_match_companies}
\title{clean_and_match_companies}
\usage{
clean_and_match_companies(df, name_col, similarity_threshold = 0.85)
}
\arguments{
\item{df}{A data frame containing company names.}

\item{name_col}{A string specifying the column in \code{df} that contains
company names to be cleaned and matched.}

\item{similarity_threshold}{Numeric value between 0 and 1. Two cleaned names
are considered a match when their cosine similarity is greater than or
equal to this threshold. Defaults to \code{0.85}.}
}
\value{
A data frame containing:
\describe{
\item{Initial_name}{The original company name.}
\item{Clean}{The cleaned, lowercased, normalised version.}
\item{Clean2}{The token-sorted canonical name string.}
\item{Matched}{The next adjacent company name (original form) whose
cleaned version exceeds the similarity threshold, or \code{NA} if no
similar neighbour was found.}
}
}
\description{
This function standardises company names, normalises legal forms, replaces
common long terms with short equivalents, sorts tokens alphabetically, and
performs adjacency-based fuzzy matching to identify potential duplicates.
}
\details{
The goal is to clean noisy company names (from patents, publications, or
business registries) and detect likely matches using cosine similarity
between token-sorted representations of each name.

The cleaning pipeline consists of the following steps:
\enumerate{
\item Convert all names to lowercase.
\item Remove Dutch and international legal forms (e.g., \code{BV}, \code{NV},
\code{LLC}, \code{Ltd}, \code{GmbH}, \code{Stichting}).
\item Replace common long words with shorter canonical forms (e.g.,
\code{"technology" → "tech"}, \code{"university" → "univ"}).
\item Remove punctuation and normalise whitespace.
\item Split each name into tokens, alphabetically sort them, and recombine
into a canonical cleaned representation.
\item Order all names by the cleaned form and perform pairwise fuzzy
matching on adjacent entries using cosine string similarity.
}

This adjacency comparison is efficient and works well for large datasets
because token-sorted names that are similar will appear next to each other.
}
\note{
Matching is adjacency-based after alphabetical token sorting. This is highly
efficient for large datasets, but if names are very different in structure,
non-adjacent matches may not be detected.
}
\examples{
\dontrun{
df <- data.frame(
  company = c(
    "Philips Research B.V.",
    "B.V. Philips Research",
    "Royal Philips",
    "Technische Universiteit Delft",
    "Delft University of Technology"
  )
)

clean_and_match_companies(df, "company", similarity_threshold = 0.8)
}

}
